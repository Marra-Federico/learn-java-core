# Java Classes (Interfaces, abstract classes)

## Decoupling and Abstraction

![](./images/intro-typical-calling-tree.avif)

```java
// Concrete Keyboard class
class Keyboard {
    public void useKeyboard() {
        System.out.println("Keyboard in use...");
    }
}

// Concrete Monitor class
class Monitor {
    public void useMonitor() {
        System.out.println("Monitor in use...");
    }
}

// Computer class directly depends on specific implementations
class Computer {
    private Keyboard keyboard;
    private Monitor monitor;

    public Computer(Keyboard keyboard, Monitor monitor) {
        this.keyboard = keyboard;
        this.monitor = monitor;
    }

    public void useKeyboard() {
        keyboard.useKeyboard();
    }

    public void useMonitor() {
        monitor.useMonitor();
    }
}

// Main class to demonstrate tight coupling
public class Main {
    public static void main(String[] args) {
        Keyboard keyboard = new Keyboard();
        Monitor monitor = new Monitor();

        Computer computer = new Computer(keyboard, monitor);
        computer.useKeyboard();  // Output: Keyboard in use...
        computer.useMonitor();   // Output: Monitor in use...
    }
}
```

**Limitations of This Approach**

1. **Tight Coupling**:
    - If we want to use a different type of keyboard (e.g., a **WirelessKeyboard**), we **must modify the `Computer` class** to support it.
    - If a third-party library provides a new `TouchScreen`, we'd have to modify `Computer` again.

2. **No Common Abstraction**:
    - `Keyboard` and `Monitor` have no shared abstraction, meaning **we cannot treat all peripherals generically**.
    - The `Computer` class must know about **every specific peripheral type**.

3. **Redundant Code**:
    - If we add more peripherals, we'd need to create separate methods like `useMouse()`, `usePrinter()`, etc., leading to **code duplication**.

**Using interfaces for decoupling the design**
   
```java
// Keyboard interface - Defines keyboard-specific behavior
interface Keyboard {
    void useKeyboard();
}

// Monitor interface - Defines monitor-specific behavior
interface Monitor {
    void useMonitor();
}

// Concrete implementation of a Mechanical Keyboard
class MechanicalKeyboard implements Keyboard {
    @Override
    public void useKeyboard() {
        System.out.println("Typing on a mechanical keyboard...");
    }
}

// Concrete implementation of an LED Monitor
class LEDMonitor implements Monitor {
    @Override
    public void useMonitor() {
        System.out.println("Displaying on an LED monitor...");
    }
}

// Computer class depends on the interfaces, not concrete implementations
class Computer {
    private Keyboard keyboard;
    private Monitor monitor;

    public Computer(Keyboard keyboard, Monitor monitor) {
        this.keyboard = keyboard;
        this.monitor = monitor;
    }

    public void useKeyboard() {
        keyboard.useKeyboard();
    }

    public void useMonitor() {
        monitor.useMonitor();
    }
}

// Main class to demonstrate decoupling
public class Main {
    public static void main(String[] args) {
        Keyboard keyboard = new MechanicalKeyboard();
        Monitor monitor = new LEDMonitor();

        Computer computer = new Computer(keyboard, monitor);

        computer.useKeyboard();  // Output: Typing on a mechanical keyboard...
        computer.useMonitor();   // Output: Displaying on an LED monitor...
    }
}
```

**How This Approach Helps**

1. **Decoupling**:
    - `Computer` depends on the `Keyboard` and `Monitor` interfaces, **not on specific implementations**.
    - We can easily swap in a **WirelessKeyboard** or **OLEDMonitor** without modifying `Computer`.

2. **Better Extensibility**:
    - We can add new keyboard and monitor types (e.g., `TouchscreenMonitor`, `GamingKeyboard`) **without modifying existing classes**.


## Interfaces
An interface can be considered a special kind of class that can't be instantiated. An interface represents an abstract concept by defining only behavior, expressed through method declarations without implementation. To declare an interface, you should use the keyword `interface` instead of `class`. Key points:

* Interfaces cannot have constructors, as they cannot be instantiated.
* **All** methods declared in an interface are implicitly **public** and **abstract**.
* Other classes can **implement** an interface by providing concrete implementations for its abstract methods.
* A common drawback of using interfaces directly is the potential for **code duplication** across implementing classes.

**Abstract methods** are declared by adding the keyword **`abstract`**. They have a declaration (modifiers, a return type, and a signature) but don't have an implementation. Each concrete (non-abstract) subclass must implement these methods.

```mermaid
classDiagram
   class DrawingTool {
      <<interface>>
      + void draw(Curve curve)
      + Color getColor()
      + void setColor(Color color)
   }

   class Pencil {
      - Color color
      + Pencil(Color color)
      + Color getColor()
      + void setColor(Color color)
      + String draw(Curve curve)
   }

   class Brush {
      - Color color
      + Brush(Color color)
      + Color getColor()
      + void setColor(Color color)
      + String draw(Curve curve)
   }

   DrawingTool <|.. Pencil
   DrawingTool <|.. Brush
```

```java
interface DrawingTool {
    void draw(Curve curve);
    Color getColor();
    void setColor(Color color);
}
```

```java
class Pencil implements DrawingTool {
    Color color;
    
    public Pencil(Color color) {
        this.color = color;
    }
    
    public Color getColor() {
        return color;
    }
    
    public void setColor(Color color) {
        this.color = color;
    }

    @Override
    public String draw(Curve curve) {
        return "Pencil drawing a " + curve.draw();
    }
}
```


```java
class Brush implements DrawingTool {
   Color color;

   public Pencil(Color color) {
      this.color = color;
   }

   public Color getColor() {
      return color;
   }

   public void setColor(Color color) {
      this.color = color;
   }

    @Override
    public String draw(Curve curve) {
        return "Brush drawing a " + curve.draw();
    }
}
```


### Key rules

An interface can extend one or more other interfaces using the keyword `extends`:

```java
interface A { }
interface B { }
interface C { }

interface E extends A, B, C { }
```

A class can extend only one class and implement multiple interfaces:

```java
class A { }

interface B { }
interface C { }

class D extends A implements B, C { }
```

Multiple interfaces are often used in the standard library. The class String, for example, implements three interfaces at once:

```java
public final class String implements Serializable, Comparable<String>, CharSequence {
    // ...
}
```

### Methods with a body
#### Static methods

You can declare and implement a static method in an interface

```java
interface Car {
    static final double kmhToMph = 0.62;
    
    static double convertToMilesPerHour(double kmh) {
        return kmhToMph * kmh;
    }
    // ...
}
```

To use a static method you just need to invoke it directly from an interface

```
Car.convertToMilesPerHour(4.5);
```

The main purpose of interface static methods is to define utility functionality that is common for all classes implementing the interface. They help to avoid code duplication.



#### Default methods
**Interface methods are abstract by default**. One kind of method can have a body nevertheless. Such methods are called `default` and are available since Java 8.

```java
interface Feature {
    default void action() {
        System.out.println("Default action");
    }
}
```

Although default methods are implemented, you cannot invoke them directly from an interface like `Feature.action()`. You still need to have an object of a class that implements the interface:

```java
class FeatureImpl implements Feature {
    // ...
}
```

```
Feature feature = new FeatureImpl();
feature.action(); // Default action
```

If you want to customize a default method in a class, just override it like a regular method:

```java
class FeatureImpl implements Feature {
    public void action() {
        System.out.println("FeatureImpl-specific action");
    }
}
```

```
Feature feature = new FeatureImpl();
feature.action(); // FeatureImpl-specific action
```

#### Private methods
Sometimes default methods are huge. To make it possible to decompose such methods, **Java allows declaring private methods inside an interface**:

```java
interface Feature {
    default void action() {
        String answer = subAction();
        System.out.println(answer);
    }

    private String subAction() {
        return "Default action";
    }
}
```

**Why are default methods useful?**

**The main reason is supporting backward compatibility**. Let's consider an example. Suppose you program a game that has several types of characters. These characters are able to move within a map. That is represented by the `Movable` interface:

```java
interface Movable {
    void stepForward();
    void stepBackward();
    void turnLeft();
    void turnRight();
}
```

So we have the interface and many classes that implement it. For example, `Batman`, `Robin`, `Joker` characters:

```java
class Batman implements Movable {
    public void stepForward() { /*...*/ }
    public void stepBackward() { /*...*/ }
    public void turnLeft() { /*...*/ }
    public void turnRight() {/*...*/ }
}
```

Then you decide that characters should be able to turn around. That means you need to add the `turnAround` method to the `Movable` interface **and implement the method for all classes implementing the interface** (if those classes are a lot this could become very time-consuming!). 

Another way is declaring a `default` method in the interface. Then you don't have to implement it in all classes.

```java
interface Movable {
    void stepForward();
    void stepBackward();
    void turnLeft();
    void turnRight();
    default void turnAround() {
        turnLeft();
        turnRight();
    }
}
```

## Abstract classes

An **abstract class** is a class declared with the keyword **`abstract`**. It represents an abstract concept that is used as a base class for subclasses. Abstract classes have some special features:

-   it's **impossible to create an instance** of an abstract class;
-   it **can contain abstract methods** (implemented in non-abstract subclasses);
-   it can contain non-abstract methods;
-   an abstract class can extend another class, including an abstract one;
-   it can contain a constructor.

```mermaid
classDiagram
   class AbstractDrawingTool {
      - Color color
      + AbstractDrawingTool(Color color)
      + Color getColor()
      + void setColor(Color color)
      + abstract String draw()
   }

   class Pencil {
      + Pencil(Color color)
      + String draw(Curve curve)
   }

   class Brush {
      + Brush(Color color)
      + String draw(Curve curve)
   }

   AbstractDrawingTool <|-- Pencil
   AbstractDrawingTool <|-- Brush
```

```java
public abstract class AbstractDrawingTool {

    protected Color color;

    protected DrawingTool(Color color) {
        this.color = color;
    }

    protected Color getColor() {
        return color;
    }

    protected void setColor(Color color) {
        this.color = color;
    }

    public abstract String draw(); // an abstract method
}
```

Since `AbstractDrawingTool` is an abstract class we cannot create instances of this class:

```java
AbstractDrawingTool pencil = new AbstractDrawingTool(Color.RED); // this throws a compile time error
```

The method `draw()` is declared abstract because, at this level of abstraction, its implementation is unknown. Concrete subclasses of the class `AbstractDrawingTool` should have an implementation of this method.

```java
class Pencil extends AbstractDrawingTool {

    // It can have additional fields as well

    public Pencil(Color color) {
        super(color);
    }

    @Override
    public String draw(Curve curve) {
        return "Pencil drawing a " + curve.draw();
    }
}
```


```java
class Brush extends AbstractDrawingTool {

    // It can have additional fields as well

    public Pencil(Color color) {
        super(color);
    }

    @Override
    public String draw(Curve curve) {
        return "Brush drawing a " + curve.draw();
    }
}
```

## Mixing Abstract classes and Interfaces

Often interfaces and abstract classes are used together to make a class hierarchy more flexible. In this case, an abstract class contains common members and implements one or multiple interfaces, and concrete classes extend the abstract class and possibly implement other interfaces.

```mermaid
classDiagram
   class DrawingTool {
      <<interface>>
      + String draw(Curve curve)
   }

   class AbstractDrawingTool {
      # Color color
      + AbstractDrawingTool(Color color)
      # Color getColor()
      # void setColor(Color color)
      + abstract String draw()
   }

   class Pencil {
      + Pencil(Color color)
      + String draw(Curve curve)
   }

   class Brush {
      + Brush(Color color)
      + String draw(Curve curve)
   }

   DrawingTool <|.. AbstractDrawingTool
   AbstractDrawingTool <|-- Pencil
   AbstractDrawingTool <|-- Brush
```

```java
interface DrawingTool {
    String draw(Curve curve);
}
```


```java
abstract class AbstractDrawingTool implements DrawingTool {
    protected Color color;

    protected AbstractDrawingTool(Color color) {
        this.color = color;
    }

    protected Color getColor() {
        return color;
    }

    protected void setColor(Color color) {
        this.color = color;
    }

    public abstract String draw(); // an abstract method
}
```

```java
class Pencil extends AbstractDrawingTool {

    // It can have additional fields as well

    public Pencil(Color color) {
        super(color);
    }

    @Override
    public String draw(Curve curve) {
        return "Pencil drawing a " + curve.draw();
    }
}
```

```java
class Brush extends AbstractDrawingTool {

    // It can have additional fields as well

    public Pencil(Color color) {
        super(color);
    }

    @Override
    public String draw(Curve curve) {
        return "Brush drawing a " + curve.draw();
    }
}
```

Using both concepts (interfaces and abstract classes) makes your code more flexible. Use suitable abstractions or their combination when designing your class hierarchies.

As an example, you may see class hierarchies in the standard Java class library. An example of that is the collections' hierarchy. It combines abstract classes and interfaces to make the hierarchy more maintainable and flexible to use in your code.


## Resources
