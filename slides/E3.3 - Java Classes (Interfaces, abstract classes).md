# Java Classes (Interfaces, abstract classes)

## Decoupling and Abstraction

![](./images/intro-typical-calling-tree.avif)

```java
class Pencil {
    public void draw() {
        System.out.println("Pencil in use...");
    }
}

class Brush {
    public void draw() {
        System.out.println("Brush in use...");
    }
}

// Computer class directly depends on specific implementations
class DrawingApplication {
    private Pencil pencil;
    private Brush brush;

    public DrawingApplication(Pencil pencil, Brush brush) {
        this.pencil = pencil;
        this.brush = brush;
    }

    public void usePencil() {
        pencil.draw();
    }

    public void useBrush() {
        brush.draw();
    }
}

// Main class to demonstrate tight coupling
public class Main {
    public static void main(String[] args) {
        Pencil pencil = new Pencil();
        Brush brush = new Brush();
        DrawingApplication app = new DrawingApplication(pencil, brush);

        app.useBrush();
        app.usePencil();
    }
}
```

**Limitations of This Approach:**

* **Tight Coupling**:
    - If we want to use a different type of Pencil (e.g., a RedPencil), we must modify the `DrawingApplication` class.
    - If we want to use a different type of Brush (e.g., a LargeBrush), we must modify the `DrawingApplication` class.

* **No Common Abstraction**:
    - `Pencil` and `Brush` have no shared abstraction, meaning **we cannot treat all tools generically**.
    - The `DrawingApplication` class **must know about every specific tool type**.

Alternatively, we can organize our project as follows:

```java
interface DrawingTool {
    public void draw();
}

class Pencil implements DrawingTool {

    @Override
    public void draw() {
        System.out.println("Pencil in use...");
    }
}

class Brush implements DrawingTool {

    @Override
    public void draw() {
        System.out.println("Brush in use...");
    }
}

// Computer class directly depends on specific implementations
class DrawingApplication {
    private DrawingTool tool;

    public DrawingApplication(DrawingTool tool) {
        this.tool = tool;
    }

    public void useTool() {
        tool.draw();
    }
}

// Main class to demonstrate tight coupling
public class Main {
    public static void main(String[] args) {
        DrawingTool pencil = new Pencil();
        //DrawingTool brush = new Brush();
        DrawingApplication app = new DrawingApplication(pencil);

        app.useTool();
    }
}
```

**How This Approach Helps:**

1. **Decoupling**:
    - `DrawingApplication` depends on the `DrawingTool` interface, **not on specific implementations**.
    - We can easily swap in a Pencil or Brush without modifying `DrawingApplication`.

2. **Better Extensibility**:
    - We can add new tools (e.g., `RedPencil`, `LargeBrush`) **without modifying existing classes**.


## Interfaces
An interface can be considered a special kind of class that can't be instantiated. An interface represents an abstract concept by defining only behavior, expressed through method declarations without implementation. To declare an interface, you should use the keyword `interface` instead of `class`. Key points:

* Interfaces cannot have constructors, as they cannot be instantiated.
* **All** methods declared in an interface are implicitly **public** and **abstract**.
* Other classes can **implement** an interface by providing concrete implementations for its abstract methods.
* A common drawback of using interfaces directly is the potential for **code duplication** across implementing classes.

**Abstract methods** are declared by adding the keyword **`abstract`**. They have a declaration (modifiers, a return type, and a signature) but don't have an implementation. Each concrete (non-abstract) subclass must implement these methods.

```mermaid
classDiagram
   class DrawingTool {
      <<interface>>
      + void draw(Curve curve)
      + Color getColor()
      + void setColor(Color color)
   }

   class Pencil {
      - Color color
      + Pencil(Color color)
      + Color getColor()
      + void setColor(Color color)
      + String draw(Curve curve)
   }

   class Brush {
      - Color color
      + Brush(Color color)
      + Color getColor()
      + void setColor(Color color)
      + String draw(Curve curve)
   }

   DrawingTool <|.. Pencil
   DrawingTool <|.. Brush
```

```java
interface DrawingTool {
    void draw(Curve curve);
    Color getColor();
    void setColor(Color color);
}
```

```java
class Pencil implements DrawingTool {
    Color color;
    
    public Pencil(Color color) {
        this.color = color;
    }
    
    public Color getColor() {
        return color;
    }
    
    public void setColor(Color color) {
        this.color = color;
    }

    @Override
    public String draw(Curve curve) {
        return "Pencil drawing a " + curve.draw();
    }
}
```


```java
class Brush implements DrawingTool {
   Color color;

   public Pencil(Color color) {
      this.color = color;
   }

   public Color getColor() {
      return color;
   }

   public void setColor(Color color) {
      this.color = color;
   }

    @Override
    public String draw(Curve curve) {
        return "Brush drawing a " + curve.draw();
    }
}
```


### Key rules

An interface can extend one or more other interfaces using the keyword `extends`:

```java
interface A { }
interface B { }
interface C { }

interface E extends A, B, C { }
```

A class can extend only one class and implement multiple interfaces:

```java
class A { }

interface B { }
interface C { }

class D extends A implements B, C { }
```

Multiple interfaces are often used in the standard library. The class String, for example, implements three interfaces at once:

```java
public final class String implements Serializable, Comparable<String>, CharSequence {
    // ...
}
```

### Methods with a body
#### Static methods

You can declare and implement a static method in an interface

```java
interface Car {
    static final double kmhToMph = 0.62;
    
    static double convertToMilesPerHour(double kmh) {
        return kmhToMph * kmh;
    }
    // ...
}
```

To use a static method you just need to invoke it directly from an interface

```
Car.convertToMilesPerHour(4.5);
```

The main purpose of interface static methods is to define utility functionality that is common for all classes implementing the interface. They help to avoid code duplication.



#### Default methods
**Interface methods are abstract by default**. One kind of method can have a body nevertheless. Such methods are called `default` and are available since Java 8.

```java
interface Feature {
    default void action() {
        System.out.println("Default action");
    }
}
```

Although default methods are implemented, you cannot invoke them directly from an interface like `Feature.action()`. You still need to have an object of a class that implements the interface:

```java
class FeatureImpl implements Feature {
    // ...
}
```

```
Feature feature = new FeatureImpl();
feature.action(); // Default action
```

If you want to customize a default method in a class, just override it like a regular method:

```java
class FeatureImpl implements Feature {
    public void action() {
        System.out.println("FeatureImpl-specific action");
    }
}
```

```
Feature feature = new FeatureImpl();
feature.action(); // FeatureImpl-specific action
```

#### Private methods
Sometimes default methods are huge. To make it possible to decompose such methods, **Java allows declaring private methods inside an interface**:

```java
interface Feature {
    default void action() {
        String answer = subAction();
        System.out.println(answer);
    }

    private String subAction() {
        return "Default action";
    }
}
```

**Why are default methods useful?**

**The main reason is supporting backward compatibility**. Let's consider an example. Suppose you program a game that has several types of characters. These characters are able to move within a map. That is represented by the `Movable` interface:

```java
interface Movable {
    void stepForward();
    void stepBackward();
    void turnLeft();
    void turnRight();
}
```

So we have the interface and many classes that implement it. For example, `Batman`, `Robin`, `Joker` characters:

```java
class Batman implements Movable {
    public void stepForward() { /*...*/ }
    public void stepBackward() { /*...*/ }
    public void turnLeft() { /*...*/ }
    public void turnRight() {/*...*/ }
}
```

Then you decide that characters should be able to turn around. That means you need to add the `turnAround` method to the `Movable` interface **and implement the method for all classes implementing the interface** (if those classes are a lot this could become very time-consuming!). 

Another way is declaring a `default` method in the interface. Then you don't have to implement it in all classes.

```java
interface Movable {
    void stepForward();
    void stepBackward();
    void turnLeft();
    void turnRight();
    default void turnAround() {
        turnLeft();
        turnRight();
    }
}
```

## Abstract classes

An **abstract class** is a class declared with the keyword **`abstract`**. It represents an abstract concept that is used as a base class for subclasses. Abstract classes have some special features:

-   it's **impossible to create an instance** of an abstract class;
-   it **can contain abstract methods** (implemented in non-abstract subclasses);
-   it can contain non-abstract methods;
-   an abstract class can extend another class, including an abstract one;
-   it can contain a constructor.

```mermaid
classDiagram
   class AbstractDrawingTool {
      - Color color
      + AbstractDrawingTool(Color color)
      + Color getColor()
      + void setColor(Color color)
      + abstract String draw()
   }

   class Pencil {
      + Pencil(Color color)
      + String draw(Curve curve)
   }

   class Brush {
      + Brush(Color color)
      + String draw(Curve curve)
   }

   AbstractDrawingTool <|-- Pencil
   AbstractDrawingTool <|-- Brush
```

```java
public abstract class AbstractDrawingTool {

    protected Color color;

    protected DrawingTool(Color color) {
        this.color = color;
    }

    protected Color getColor() {
        return color;
    }

    protected void setColor(Color color) {
        this.color = color;
    }

    public abstract String draw(); // an abstract method
}
```

Since `AbstractDrawingTool` is an abstract class we cannot create instances of this class:

```java
AbstractDrawingTool pencil = new AbstractDrawingTool(Color.RED); // this throws a compile time error
```

The method `draw()` is declared abstract because, at this level of abstraction, its implementation is unknown. Concrete subclasses of the class `AbstractDrawingTool` should have an implementation of this method.

```java
class Pencil extends AbstractDrawingTool {

    // It can have additional fields as well

    public Pencil(Color color) {
        super(color);
    }

    @Override
    public String draw(Curve curve) {
        return "Pencil drawing a " + curve.draw();
    }
}
```


```java
class Brush extends AbstractDrawingTool {

    // It can have additional fields as well

    public Pencil(Color color) {
        super(color);
    }

    @Override
    public String draw(Curve curve) {
        return "Brush drawing a " + curve.draw();
    }
}
```

## Mixing Abstract classes and Interfaces: Example 1

Often interfaces and abstract classes are used together to make a class hierarchy more flexible. 

* **Interface**: Defines basic banking operations that any account type must implement.

* **Abstract Class**: Implements common state and behavior (like managing the balance) and provides a foundation for concrete account types.

* **Concrete Classes**: Specialize behavior for each type of account (e.g., overdraft rules, interest application).

```mermaid
classDiagram
   class DrawingTool {
      <<interface>>
      + String draw(Curve curve)
   }

   class AbstractDrawingTool {
      # Color color
      + AbstractDrawingTool(Color color)
      # Color getColor()
      # void setColor(Color color)
      + abstract String draw()
   }

   class Pencil {
      + Pencil(Color color)
      + String draw(Curve curve)
   }

   class Brush {
      + Brush(Color color)
      + String draw(Curve curve)
   }

   DrawingTool <|.. AbstractDrawingTool
   AbstractDrawingTool <|-- Pencil
   AbstractDrawingTool <|-- Brush
```

```java
interface DrawingTool {
    String draw(Curve curve);
}
```


```java
abstract class AbstractDrawingTool implements DrawingTool {
    protected Color color;

    protected AbstractDrawingTool(Color color) {
        this.color = color;
    }

    protected Color getColor() {
        return color;
    }

    protected void setColor(Color color) {
        this.color = color;
    }

    public abstract String draw(); // an abstract method
}
```

```java
class Pencil extends AbstractDrawingTool {

    // It can have additional fields as well

    public Pencil(Color color) {
        super(color);
    }

    @Override
    public String draw(Curve curve) {
        return "Pencil drawing a " + curve.draw();
    }
}
```

```java
class Brush extends AbstractDrawingTool {

    // It can have additional fields as well

    public Pencil(Color color) {
        super(color);
    }

    @Override
    public String draw(Curve curve) {
        return "Brush drawing a " + curve.draw();
    }
}
```

## Mixing Abstract classes and Interfaces: Example 2

Here is another example of **mixing abstract classes and interfaces**, this time to model **two types of bank accounts**: a **SavingsAccount** and a **CheckingAccount**. The interface defines general bank operations, and the abstract class handles shared logic (e.g., balance management).

```mermaid
classDiagram
   class BankAccount {
      <<interface>>
      + deposit(double amount)
      + withdraw(double amount)
      + double getBalance()
   }

   class AbstractBankAccount {
      - double balance
      + AbstractBankAccount(double initialBalance)
      + void deposit(double amount)
      + double getBalance()
      + abstract void withdraw(double amount)
   }

   class SavingsAccount {
      + SavingsAccount(double initialBalance)
      + void withdraw(double amount)
   }

   class CheckingAccount {
      + CheckingAccount(double initialBalance)
      + void withdraw(double amount)
   }

   BankAccount <|.. AbstractBankAccount
   AbstractBankAccount <|-- SavingsAccount
   AbstractBankAccount <|-- CheckingAccount
```

```java
interface BankAccount {
    void deposit(double amount);
    void withdraw(double amount);
    double getBalance();
}
```

```java
abstract class AbstractBankAccount implements BankAccount {
    protected double balance;

    public AbstractBankAccount(double initialBalance) {
        this.balance = initialBalance;
    }

    @Override
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        }
    }

    @Override
    public double getBalance() {
        return balance;
    }

    @Override
    public abstract void withdraw(double amount);
}
```

```java
class SavingsAccount extends AbstractBankAccount {

    public SavingsAccount(double initialBalance) {
        super(initialBalance);
    }

    @Override
    public void withdraw(double amount) {
        if (amount > 0 && balance >= amount) {
            balance -= amount;
        } else {
            throw new IllegalArgumentException("Insufficient funds in SavingsAccount");
        }
    }
}
```

```java
class CheckingAccount extends AbstractBankAccount {

    private static final double OVERDRAFT_LIMIT = 100.0;

    public CheckingAccount(double initialBalance) {
        super(initialBalance);
    }

    @Override
    public void withdraw(double amount) {
        if (amount > 0 && balance + OVERDRAFT_LIMIT >= amount) {
            balance -= amount;
        } else {
            throw new IllegalArgumentException("Overdraft limit exceeded in CheckingAccount");
        }
    }
}
```

Sure! Here's a new section that explains how **this kind of class organization (interface + abstract class)** is used in the **Java Collections Framework**.


## Mixing Abstract classes and Interfaces: Example 3

The **Java Collections Framework** is a classic example of how **interfaces and abstract classes are combined** to create a **flexible and extensible hierarchy**.

* **Interfaces** define *what* a collection can do (e.g., `add`, `remove`, `iterate`).
* **Abstract classes** provide *reusable logic* and *partial implementations* to reduce code duplication.
* **Concrete classes** specialize behavior for different use cases (e.g., lists vs. sets vs. queues).

```mermaid
classDiagram
   class List {
      <<interface>>
      + add(E e)
      + remove(int index)
      + E get(int index)
   }

   class AbstractList {
      - int size
      + int size()
      + boolean isEmpty()
      + abstract void add(E e)
      + abstract E get(int index)
   }

   class ArrayList {
      + add(E e)
      + E get(int index)
   }

   class LinkedList {
      + add(E e)
      + E get(int index)
   }

   List <|.. AbstractList
   AbstractList <|-- ArrayList
   AbstractList <|-- LinkedList
```

## Resources
